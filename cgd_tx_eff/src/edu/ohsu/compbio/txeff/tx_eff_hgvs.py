'''
Read file generated by tx_eff_annovar.py, update transcript information using HGVS, and write out a CSV file with variant transcript effects.

Requires Python 3.8. 
 - If you use Python 3.9 change the import of Iterable to ``from collections.abc import Iterable``
 
Created on Apr 20, 2022

@author: pleyte
'''

from collections import defaultdict
import csv
import logging
import os
from pathlib import Path

import hgvs.assemblymapper
import hgvs.dataproviders.uta
from hgvs.exceptions import HGVSInvalidVariantError, HGVSUsageError, HGVSDataNotAvailableError, \
    HGVSInvalidIntervalError, HGVSUnsupportedOperationError
from hgvs.sequencevariant import SequenceVariant

from edu.ohsu.compbio.annovar import annovar_parser
from edu.ohsu.compbio.annovar.annovar_parser import AnnovarVariantFunction
from edu.ohsu.compbio.txeff.util import chromosome_map
from edu.ohsu.compbio.txeff.util.benchmarking import Benchmarking
from edu.ohsu.compbio.txeff.util.tx_eff_pysam import PysamTxEff
from edu.ohsu.compbio.txeff.variant import Variant
from edu.ohsu.compbio.txeff.variant_transcript import VariantTranscript

# When we upgrade from python 3.8 to 3.9 this import needs to be changed to: "from collections.abc import Iterable"
ASSEMBLY_VERSION = "GRCh37"

class RptHandler:
    """
    Handle coordinate changes due to repetitive sequences in both deletions and duplications.  HGVS requires
    alignment to the 3' side, whereas VCF is 5'.
    """
    def __init__(self, pysamtxeff: PysamTxEff, chrom: str, coord: int, allele: str):
        """
        Window search size given by self.size (from PysamTxEff).  Sequence constructed based on location of variant
        and given search window size.  FASTA alt contains the sequence at the position of the potential rpt seq,
        matching the allele size.
        :param pysamtxeff: Pysam faidx coordinate search object
        :param chrom: chromosome for search
        :param coord: coordinate for search
        :param allele: the allele that contains the potentially repetitive del or dup
        """
        self.pysamtxeff = pysamtxeff
        self.chrom = chrom
        self.coord = coord
        self.allele = allele[1:]
        self.size = self.pysamtxeff.size
        self.seq = self.pysamtxeff.faidx_query(self.chrom, self.coord)
        self.fasta_alt = self.seq[self.size + 1:self.size + len(self.allele) + 1]

    def check_rpt_status(self) -> bool:
        """
        Check to see if the del/dup allele and sequence at the current search position match.
        :return:
        """
        return self.allele == self.fasta_alt

    def find_rpt_coords(self) -> (int, int):
        """
        Search for a repetitive allele in the reference, until there are no more.  Then return the start/stop
        coordinates associated with the updated 3' position.
        :return:
        """
        start_size = self.size
        end_size = self.size + len(self.allele)
        coord = self.coord
        fasta_alt = self.fasta_alt
        while self.allele == fasta_alt:
            coord += len(self.allele)
            start_size += len(self.allele)
            end_size += len(self.allele)
            fasta_alt = self.seq[start_size:end_size]
        new_start = coord - len(self.allele)
        new_end = new_start + len(self.allele) - 1
        return new_start, new_end
        
class TxEffHgvs(object):
    """
    Finds transcripts associated with variant. Makes use of the SeqRepo and UTA datasources. 
    Benchmarking can be enabled to produce a csv file that shows how long SeqRepo and UTA queries are taking. 
    """ 
    def __init__(self, sequence_source = None, benchmark = False):
        self.logger = logging.getLogger(__name__)
        self._sequence_source = sequence_source
        self._benchmarking = None
        
        # Setup benchmarking if it is requested
        if benchmark:
            self._benchmarking = Benchmarking()

            self._benchmark_file = open("benchmark.csv", 'w')
            self.logger.info(f"Benchmarking enabled. Writing to {self._benchmark_file.name}") 
            self._benchmark_csv_writer = csv.writer(self._benchmark_file)
            self._benchmark_csv_writer.writerow(['variant', 'name', 'transcript_count', 'total_time', 'average_time'])
 
    def __enter__(self):
        '''
        Open database connection  
        '''        
        # Configure biocommons-hgvs to use the SeqRepo rest service, file repository, or the the NCBI api.
        self._configure_sequence_source()

        # Initialize the UTA database connection        
        self._configure_uta()

        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.logger.debug("Closing UTA connection")
        self.hdp.close()
        
        if self._benchmarking:
            self._benchmark_file.close() 

    def _configure_uta(self):
        self.logger.debug("Opening UTA connection")
        
        if not os.environ.get('UTA_DB_URL'):
            # This option won't work from within OHSU's network because they seem to block us.  
            self.logger.warning("The UTA_DB_URL environment variable is not defined. The remote public postgresql database at uta.biocommons.org will be used.")
        else:
            # This leaks the password. Consider splitting the string: postgresql://name:password@host:5432/uta/uta_20210129
            self.logger.info(f"Using UTA Database at {os.environ.get('UTA_DB_URL')}")

        # Initialize the HGVS connection        
        self.hdp = hgvs.dataproviders.uta.connect()
        self.am = hgvs.assemblymapper.AssemblyMapper(self.hdp, assembly_name=ASSEMBLY_VERSION, alt_aln_method='splign')
        self.hgvs_parser = hgvs.parser.Parser()      
          
    def _configure_sequence_source(self):
        """
        The biocommons-hgvs module needs a way to lookup reference sequences. There are three options:
        * Use local SeqRepo installation
            - This is the most performant solution when SeqRepo is installed on the same host as Transcript Effects running. 
            - SeqRepo files are too large be be opened over a network file system.
            - To use this method set the environment variable HGVS_SEQREPO_DIR with the path to the SeqRepo installation.    
        * Use SeqRepo REST API to query a remote SeqRepo installation
            - For production use Transcript Effects runs on a Galaxy node and we access SeqRepo using the SeqRepo REST service. 
            - To use this method set the environment variable HGVS_SEQREPO_URL with the url of the SeqRepo service.  
        * Use NCBI's E-Utilties API instead of SeqRepo
            - Instead of using SeqRepo, biocommons-hgvs can lookup sequences using NCBI's E-Utilities API. 
            - To use this method use you create an NCBI account, generate an API key and set it in the NCBI_API_KEY environment variable. 
            - This option works great but we have not investigated its dependability as a production resource.      
        
        The KCC Galaxy instances define the HGVS_SEQREPO_DIR environment variable. But it is on a networked file system. If you add 
        HGVS_SEQREPO_URL to the environment, biocommons-hgvs will still use the file repository so it is necessary to unset
        HGVS_SEQREPO_DIR when we want to use the SeqRepo service.
        
        This function sets up the environment prioritizing the sequence options the order:
        0. The method specified by the optional sequence_source parameter
        1. The SeqRepo REST service found in the HGVS_SEQREPO_URL environment variable
        2. The SeqRepo file repository found in the HGVS_SEQREPO_DIR environment variable. 
        3. NCBI E-Utilities when neither environment variable is defined. 
        """
        self.logger.debug("Determining SeqRepo repository location")
        
        env_seqrepo_url = os.environ.get('HGVS_SEQREPO_URL')
        env_seqrepo_directory = os.environ.get('HGVS_SEQREPO_DIR')
        
        # If they want to use ncbi then the other two options have to be disabled
        if self._sequence_source == 'ncbi' \
           or (not self._sequence_source and not env_seqrepo_url and not env_seqrepo_directory):

            self.logger.info("Reference sequences will be retrieved using NCBI's E-Utilities API")
            self.logger.warning("The NCBI API should only be used for testing. Do not use it in a production environment.")
            
            if os.environ.get('NCBI_API_KEY'):
                self.logger.info(f"NCBI API Key is present: {os.environ.get('NCBI_API_KEY')}")
            else:
                # The n queries per second limit will cause delays and possibly failure  
                self.logger.warning("Using NCBI's E-Utilities without an NCBI API Key is discouraged")

            os.environ.pop('HGVS_SEQREPO_DIR', None)
            os.environ.pop('HGVS_SEQREPO_URL', None)
            return 1
        
        # Default is to prioritize the service over the file repository 
        if not self._sequence_source and env_seqrepo_url:
            if not env_seqrepo_url.lower().startswith('http'):
                self.logger.warning("The SeqRepo service is requested but the URL appears invalid: " + env_seqrepo_url)
            else: 
                self.logger.info("Reference sequences will be retrieved using the SeqRepo service: " + env_seqrepo_url)
            
            # Remove HGVS_SEQREPO_DIR from environment since biocommons.hgvs prioritizes it over the SeqRepo service.
            os.environ.pop('HGVS_SEQREPO_DIR', None)
            return 2
                
        if not self._sequence_source and env_seqrepo_directory:
            if not Path(env_seqrepo_directory).is_dir():
                self.logger.warning("The SeqRepo file repository is requested but the path appears invalid: " + env_seqrepo_directory)
            else:
                self.logger.info("Reference sequences will be retrieved using the SeqRepo file repository: " + env_seqrepo_directory)
            
            os.environ.pop('HGVS_SEQREPO_URL', None)
            return 3
        
        # If the sequence parameter is a URL then the SeqRepo service will be used. 
        if self._sequence_source and self._sequence_source.lower().startswith('http'):
            self.logger.info("Reference sequences will be retrieved using the SeqRepo service: " + self._sequence_source)
            os.environ['HGVS_SEQREPO_URL'] = self._sequence_source
            os.environ.pop('HGVS_SEQREPO_DIR', None)
            return 4
        
        if self._sequence_source and self._sequence_source.startswith("/"):
            if not Path(self._sequence_source).is_dir():
                self.logger.warning("The SeqRepo file repository is requested but the path appears invalid: " + self._sequence_source)
            else:
                self.logger.info("Reference sequences will be retrieved using the SeqRepo file repository: " + self._sequence_source)
            
            os.environ['HGVS_SEQREPO_DIR'] = self._sequence_source
            os.environ.pop('HGVS_SEQREPO_URL', None)
            return 5
        
        raise ValueError("The sequence_source parameter must be a url, a path, or 'ncbi': " + self._sequence_source)
                
    def _noneIfEmpty(self, value: str):
        '''
        Return None if the string is an empty string.
        ''' 
        if value == '':
            return None
        return value

    def _correct_indel_coords(self, chrom, pos, ref, alt, pysamtxeff):
        """
        Using a VCF position, create coords that are compatible with HGVS nomenclature.
        Since we are already determining at this stage whether the event is an ins or del, also
        include the ins or del strings in the result.
        substitution event -> ac:g.[pos][ref]>[alt]
        :return:
        """
        lref = len(ref)
        lalt = len(alt)
        if lref == 1 and lalt == 1:
            # Substitution case
            change = '>'.join([ref, alt])
            new_pos = str(pos) + change
            return new_pos
        elif lalt == 1 and lref > lalt:
            dels = RptHandler(pysamtxeff, chrom, pos, ref)
            # Deletion case
            if dels.check_rpt_status():
                new_start, new_end = dels.find_rpt_coords()
                if len(dels.allele) == 1:
                    new_pos = '_'.join([str(new_start)]) + 'del'
                else:
                    new_pos = '_'.join([str(new_start), str(new_end)]) + 'del'
            else:
                shift = lref - lalt
                if shift == 1:
                    new_pos = str(int(pos) + 1) + 'del'
                else:
                    new_start = str(int(pos) + 1)
                    new_end = str(int(pos) + shift)
                    new_pos = '_'.join([new_start, new_end]) + 'del'
            return new_pos
        elif lref == 1 and lalt > lref:
            dups = RptHandler(pysamtxeff, chrom, pos, alt)
            # Duplication case
            if dups.check_rpt_status():
                new_start, new_end = dups.find_rpt_coords()
                # Check if there is a padding base, then adjust accordingly.
                if alt[0] == ref[0]:
                    new_start += 1
                    new_end += 1
                if len(dups.allele) == 1:
                    new_pos = '_'.join([str(new_start)]) + 'dup'
                else:
                    new_pos = '_'.join([str(new_start), str(new_end)]) + 'dup'
            # Insertion case
            else:
                new_start = str(pos)
                new_end = str(int(pos) + 1)
                new_pos = '_'.join([new_start, new_end]) + 'ins' + alt[1:]
            return new_pos
        elif lref > 1 and lalt > 1:
            # Multi-nucleotide substitution case
            # NG_012232.1: g.12_13delinsTG
            new_start = pos
            new_end = str(int(pos) + lref - 1)
            # If there is a common padding base, like ATG>ACC, make sure we are taking this in to account.
            if alt[0] == ref[0]:
                new_start += 1
                alt = alt[1:]
            new_pos = '_'.join([str(new_start), new_end]) + 'delins' + alt
            return new_pos
        else:
            raise Exception("Unknown change type: " + pos + ':' + ref + '>' + alt)
    
    def _lookup_hgvs_transcripts(self, variants: list, pysam_file):
        '''
        Return the HGVS transcripts associated with a list of variants  
        '''
        transcripts = []
        
        for variant in variants:
            hgvs_variant_transcripts = self._lookup_variant_hgvs_transcripts(variant, pysam_file)
            self.logger.info(f"HGVS found {len(hgvs_variant_transcripts)} transcripts for {variant}")

            # HGVS might not find any transcripts even though Annovar did 
            if len(hgvs_variant_transcripts) == 0: 
                self.logger.info(f'HGVS could not find any transcripts for variant {variant} which has transcripts known to Annovar.')
            else:
                transcripts.extend(hgvs_variant_transcripts)
                
        return transcripts
        
    def _lookup_variant_hgvs_transcripts(self, variant: Variant, pysam_file):
        '''
        Use HGVS/UTA to return a list of the transcripts for a variant
        
        '''
        self.logger.debug(f"Using HGVS/UTA to find transcripts for {variant}")
    
        # Even the numeric chromosomes need to be strings in order to be found in the chromosome map
        assert type(variant.chromosome) == str 
        
        refseq_chromosome = chromosome_map.get_refseq(variant.chromosome)
        
        # Look up the variant using HGVS
        pos_part = self._correct_indel_coords(variant.chromosome, variant.position, variant.reference, variant.alt, pysam_file)
        new_hgvs = refseq_chromosome + ':g.' + pos_part
    
        var_g = self.hgvs_parser.parse_hgvs_variant(new_hgvs)
    
        # Retrieve transcripts that are in a genomic region
        self._benchmark_start('hdp.get_tx_for_region (UTA)')
        tx_list = self.hdp.get_tx_for_region(str(var_g.ac), 'splign', var_g.posedit.pos.start.base, var_g.posedit.pos.end.base)
        self._benchmark_stop('hdp.get_tx_for_region (UTA)')
        
        hgvs_transcripts = []
        
        for uta_row in tx_list:
            refseq_transcript = uta_row[0]
            refseq_chromosome = uta_row[1]

            try:
                variant_transcript = VariantTranscript(variant.chromosome, variant.position, variant.reference, variant.alt)
    
                variant_transcript.sequence_variant = self.__to_g_dot(var_g)
                
                # Annovar doesn't provide a gene for UTR and introns, so in those cases the gene information comes from HGVS using this function.
                self._benchmark_start('hdp.get_tx_info (UTA)')
                transcript_detail = self.hdp.get_tx_info(refseq_transcript, refseq_chromosome, 'splign')
                variant_transcript.hgnc_gene = transcript_detail['hgnc']
                self._benchmark_stop('hdp.get_tx_info (UTA)')
                
                # Non-coding transcripts (prefix NR_) cause HGVS to throw an exception when determining c. and p. 
                # But instead of giving up on the transcript altogether, the transcript is saved with transcript name and gene only. 
                if refseq_transcript.startswith('NR_'):
                    variant_transcript.refseq_transcript = refseq_transcript 

                # Determine c. and p.. Non coding transcripts will throw an error. See HGVSUsageError caught below.
                self._benchmark_start('am.g_to_c (SeqRepo)') 
                var_c = self.am.g_to_c(var_g, str(refseq_transcript))
                self._benchmark_stop('am.g_to_c (SeqRepo)')

                self._benchmark_start('am.c_to_p (SeqRepo)') 
                var_p = self.am.c_to_p(var_c)
                self._benchmark_stop('am.c_to_p (SeqRepo)')
                
                # setting uncertain to False removes the parentheses on the stringified form
                if var_p.posedit:
                    var_p.posedit.uncertain = False
    
                # Convert the three letter amino acid seq to a one letter and remove the 'transcript:' prefix.             
                var_p1 = var_p.format(conf={"p_3_letter": False}).replace(var_p.ac+':','')
                var_p3 = var_p.format(conf={"p_3_letter": True}).replace(var_p.ac+':','')
    
                # Correct bug in biocommons/hgvs lib that always returns the three letter amino acid when variant is start loss. 
                if var_p1 == 'p.Met1?':
                    var_p1 = 'p.M1?'
    
                c_dot = var_c.type +'.' + str(var_c.posedit)
                
                # HGVS doesrn't provide a variant type. 
                variant_type = None
                
                # The amino acid position only exists for certain types of variants.             
                if var_p3 == 'p.?':
                    assert var_p.posedit == None, "A position is not expected with 'p.?'"                
                elif isinstance(var_p.posedit, hgvs.edit.AARefAlt):
                    # Some variants don't have any position information, and that is ok. Most of the time these are indels, as indicated by ``var_p.posedit.type``
                    self.logger.debug(f"HGVS variant does not have a position: ref={var_p.posedit.ref}, alt={var_p.posedit.alt}, type={var_p.posedit.type}, str={str(var_p.posedit)}. Keeping.")
                else:
                    variant_transcript.hgvs_amino_acid_position = var_p.posedit.pos.start.pos
    
                variant_transcript.hgvs_base_position = var_c.posedit.pos.start.base
                
                variant_transcript.hgvs_c_dot = c_dot
                variant_transcript.hgvs_p_dot_one = var_p1
                variant_transcript.hgvs_p_dot_three = var_p3
                variant_transcript.refseq_transcript = var_c.ac
                variant_transcript.variant_type = variant_type
    
                # Sometimes the am.c_to_p function returns the protein accession as an MD5 hash 
                # of the amino acid sequence (see uta.get_acs_for_protein_seq)
                if not var_p.ac.startswith('MD5'):
                    variant_transcript.protein_transcript = var_p.ac
    
                hgvs_transcripts.append(variant_transcript)
    
            except HGVSUsageError as e:
                if("non-coding transcript" in str(e)):
                    self.logger.info(f"Encountered non-coding transcript {variant}. Transcript will have name and gene only: %s", str(e))
                    
                    # Add the transcript even though an exception was thrown. At least we have the transcript+gene. 
                    hgvs_transcripts.append(variant_transcript)
                    self._benchmark_cancel()
                else:
                    raise(e)
            except HGVSInvalidVariantError as e:            
                self.logger.warning(f"Invalid variant {variant}: %s", str(e))
                raise(e)
            except HGVSUnsupportedOperationError as e:
                self.logger.warning(f"Invalid parameters while processing variant {variant}, var_g={var_g}, transcript={refseq_transcript}: %s", str(e))
                self._benchmark_cancel()
            except HGVSInvalidIntervalError as e:
                self.logger.warning(f"Invalid variant interval {variant}: %s", str(e))
                self._benchmark_cancel()
            except HGVSDataNotAvailableError as e:
                # HGSV uses this exception for unrecoverable connection errors, and for when a row in the database just wasn't found.                
                if 'alignment' in str(e).lower():
                    self.logger.info(f"HGVS alignment not found while parsing variant {variant} (see https://hgvs.readthedocs.io/en/stable/faq.html): %s", str(e))
                    self._benchmark_cancel()
                else:
                    self.logger.warning(f"Error while parsing variant {variant}: %s", str(e))
                    raise(e)
            except NotImplementedError as e:
                self.logger.warning(f"Invalid CDS sequence while processing variant {variant}: %s", str(e))
                self._benchmark_cancel()

        # Update the benchmarking log after processing each variant
        self._log_hgvs_benchmarks(variant, len(hgvs_transcripts))

        return hgvs_transcripts
    
    def __to_g_dot(self, var_g: SequenceVariant):
        '''
        Convert the SequenceVariant object to a g-dot. The string 'NC_000002.11:g.48033742_48033759dup' is split and just the g. is returned.  
        '''
        return str(var_g).split(':')[1]
    
    def _get_unmatched_annovar_transcripts(self, annovar_dict: defaultdict(AnnovarVariantFunction), hgvs_dict: defaultdict(VariantTranscript)):
        '''
        After HGVS and Annovar transcripts have been merged, this function is called to find Annovar transcripts that were not paired 
        with an HGVS trancsript. The parameters to the function are dictionaries because that facilitates quickly looking for 
        transcripts having the same genotype. 
        '''
        transcripts = []
        
        # Iterate through the annovar transcripts and see if any are in the hgvs list
        for (transcript_key, annovar_transcript) in annovar_dict.items():
            # Check the HGVS dictionary for a key matching the annovar key. If there is a match, then the annovar transcript has already  
            # been processed. If HGVS does not have the key then the annovar transcript has not been looked at.
            if hgvs_dict.get(transcript_key) == None:
                self.logger.debug(f"Adding unmatched Annovar transcript(s) for {transcript_key}")
                
                # Convert the AnnovarVariantFunction objects to VariantTranscript so all items in the list are of the VariantTranscript type. 
                transcripts.append(self.to_variant_transcript(annovar_transcript))
        
        # Iterate through the hgvs transcripts and see if any of them are in the annovar list
        for (transcript_key, hgvs_transcript) in hgvs_dict.items():
            if annovar_dict.get(transcript_key) == None:
                self.logger.debug(f"Adding unmatched HGVS transcript(s) for {transcript_key}")
                transcripts.append(hgvs_transcript)
        
        return transcripts
    
    def to_variant_transcript(self, annovar_transcript: AnnovarVariantFunction):
            '''
            Create a new VariantTranscript using the values from an object of parent type AnnovarVariantFunction
            '''
            variant_transcript = VariantTranscript(annovar_transcript.chromosome, annovar_transcript.position, annovar_transcript.reference, annovar_transcript.alt)
            variant_transcript.protein_transcript = None
            variant_transcript.variant_effect = annovar_transcript.variant_effect
            variant_transcript.variant_type = annovar_transcript.variant_type
            variant_transcript.hgvs_amino_acid_position = annovar_transcript.hgvs_amino_acid_position
            variant_transcript.hgvs_base_position = annovar_transcript.hgvs_base_position
            variant_transcript.exon = annovar_transcript.exon
            variant_transcript.hgnc_gene = annovar_transcript.hgnc_gene
            variant_transcript.hgvs_c_dot = annovar_transcript.hgvs_c_dot
            variant_transcript.hgvs_p_dot_one = annovar_transcript.hgvs_p_dot_one
            variant_transcript.hgvs_p_dot_three = annovar_transcript.hgvs_p_dot_three
            variant_transcript.splicing = annovar_transcript.splicing
            variant_transcript.refseq_transcript = annovar_transcript.refseq_transcript
            return variant_transcript
            
    def _merge_annovar_with_hgvs(self, annovar_transcripts: list, hgvs_transcripts: list):
        '''
        Given a list of transcripts from Annovar and HGVS, find those with the same genotype and transcript, and merge them into a single record.
        '''
        merged_transcripts = []
    
        # Collect annovar records into a map keyed by genotype and transcript 
        annovar_dict = defaultdict(VariantTranscript)
        for annovar_rec in annovar_transcripts:
            annovar_key = annovar_rec.get_label()
            assert annovar_key not in annovar_dict, f'A matching annovar variant-transcript should not already be in the dictionary: {annovar_rec.get_label()}'          
            annovar_dict[annovar_key] = annovar_rec
    
        # Collect hgvs records into a map keyed by genotype and transcript    
        hgvs_dict = defaultdict(VariantTranscript)
        for hgvs_rec in hgvs_transcripts:
            assert hgvs_rec.get_label() not in hgvs_dict, f'A matching hgvs variant-transcript should not already be in the dictionary: {hgvs_rec.get_label()}'
            hgvs_dict[hgvs_rec.get_label()] = hgvs_rec
    
        # Iterate over every HGVS variant-transcript and see if there is a matching Annovar transcript
        for (transcript_key, hgvs_transcript) in hgvs_dict.items():
            annovar_match = annovar_dict.get(transcript_key) 
            if not annovar_match:
                self.logger.debug(f"HGVS {transcript_key} does not match any Annovar transcripts")
            else:
                self.logger.debug(f"Merging HGVS transcript with Annovar transcript having key {transcript_key}")
                merged_transcripts.append(self._merge(transcript_key, hgvs_transcript, annovar_match))
    
        # Not all the Annovar transcripts will get matched and merged with an HGVS transcript. They will likely be discarded
        # when _get_the_best_transcripts is called but we want one version of every known transcript so we need to keep the unmerged ones.  
        unmerged_transcripts = self._get_unmatched_annovar_transcripts(annovar_dict, hgvs_dict)
    
        return merged_transcripts, unmerged_transcripts
    
    def _merge(self, transcript_key: str, hgvs_transcript: VariantTranscript, annovar_transcript: VariantTranscript):
        '''
        Combine Annovar and HGVS information relating to the same transcript into a single record.  
        '''
        new_transcript = VariantTranscript(hgvs_transcript.chromosome, hgvs_transcript.position, hgvs_transcript.reference, hgvs_transcript.alt)
    
        self._merge_into(transcript_key, new_transcript, hgvs_transcript, annovar_transcript)
            
        return new_transcript
    
    
    def _merge_into(self, transcript_key: str, new_transcript: VariantTranscript, hgvs_transcript: VariantTranscript, annovar_transcript: VariantTranscript):
        '''
        Take the best parts of the hgvs_transcript and the annovar_transcript, and place them in the new_transcript 
        '''
        assert hgvs_transcript.chromosome == annovar_transcript.chromosome, f"HGVS and Annovar genotype chromosomes are not equal: {hgvs_transcript.chromosome} != {annovar_transcript.chromosome}"
        assert hgvs_transcript.position == annovar_transcript.position, f"HGVS and Annovar genotype positions are not equal: {hgvs_transcript.position} != {annovar_transcript.position}"
        assert hgvs_transcript.reference == annovar_transcript.reference, f"HGVS and Annovar genotype references are not equal: {hgvs_transcript.reference} != {annovar_transcript.reference}"
        assert hgvs_transcript.alt == annovar_transcript.alt, f"HGVS and Annovar genotype alts are not equal: {hgvs_transcript.alt} != {annovar_transcript.alt}"
        
        # Amino Acid Position
        ## Amino acid position is commonly different between HGVS and Annovar 
        if str(hgvs_transcript.hgvs_amino_acid_position) != str(annovar_transcript.hgvs_amino_acid_position):
            self.logger.debug(f"HGVS and Annovar do not agree on amino acid position for {transcript_key}: {hgvs_transcript.hgvs_amino_acid_position} != {annovar_transcript.hgvs_amino_acid_position}")
    
        if self._allow_merge(new_transcript.hgvs_amino_acid_position, hgvs_transcript.hgvs_amino_acid_position, transcript_key, 'hgvs_amino_acid_position'):
            new_transcript.hgvs_amino_acid_position = hgvs_transcript.hgvs_amino_acid_position 
        
        # Base Position
        ## Base position may not match what HGVS says; can be empty; or will match between annovar and hgvs    
        if str(hgvs_transcript.hgvs_base_position) != str(annovar_transcript.hgvs_base_position):
            self.logger.debug(f"HGVS and Annovar do not agree on base_position for {transcript_key}: {hgvs_transcript.hgvs_base_position} != {annovar_transcript.hgvs_base_position}")    
        
        if self._allow_merge(new_transcript.hgvs_base_position, hgvs_transcript.hgvs_base_position, transcript_key, 'hgvs_base_position'):
            new_transcript.hgvs_base_position = hgvs_transcript.hgvs_base_position
        
        # Exon number
        ## Only Annovar provides exon, and the value may be empty.
        assert hgvs_transcript.exon == None
        if self._allow_merge(new_transcript.exon, annovar_transcript.exon, transcript_key, 'exon'):
            new_transcript.exon = annovar_transcript.exon 
        
        # Gene
        # Prefer annovar's gene, but annovar doesn't give us a gene for intron and utr; in those cases use hgvs's.        
        transcript_gene = annovar_transcript.hgnc_gene
        if self._noneIfEmpty(annovar_transcript.hgnc_gene) == None and self._noneIfEmpty(hgvs_transcript.hgnc_gene) == None:
            self.logger.debug(f"Gene selection: Neither Annovar or HGVS have a gene for {transcript_key}") 
        elif annovar_transcript.hgnc_gene == None:
            self.logger.debug(f"Gene selection: Annovar did not provide a gene for {transcript_key}, using HGVS's: gene={hgvs_transcript.hgnc_gene}")            
            transcript_gene = hgvs_transcript.hgnc_gene
        elif annovar_transcript.hgnc_gene != hgvs_transcript.hgnc_gene:
            self.logger.info(f"Gene selection: Annovar and HGVS genes don't match for {transcript_key}: {annovar_transcript.hgnc_gene} != {hgvs_transcript.hgnc_gene}")
        
        if self._allow_merge(new_transcript.hgnc_gene, transcript_gene, transcript_key, 'hgnc_gene'):
            new_transcript.hgnc_gene = transcript_gene
        
        # g-dot
        ## Always comes from hgvs/uta
        new_transcript.sequence_variant = hgvs_transcript.sequence_variant
    
        # c-dot
        ## Use HGVS's c. because Annovar's is not always correct. Non-coding transcripts don't have a c. 
        assert hgvs_transcript.hgvs_c_dot != None or hgvs_transcript.refseq_transcript.startswith('NR_'), "The HGVS c. value is not supposed to be empty"
        
        if hgvs_transcript.hgvs_c_dot != annovar_transcript.hgvs_c_dot:
            self.logger.debug(f"HGVS and Annovar do not agree on c_dot for {transcript_key}: {hgvs_transcript.hgvs_c_dot} != {annovar_transcript.hgvs_c_dot} ")
    
        if self._allow_merge(new_transcript.hgvs_c_dot, hgvs_transcript.hgvs_c_dot, transcript_key, 'hgvs_c_dot'):
            new_transcript.hgvs_c_dot = hgvs_transcript.hgvs_c_dot
        
        # p-dot (1L)
        ## Use HGVS's p. because Annovar's is not always correct. Non-coding transcripts don't have a p.
        assert hgvs_transcript.hgvs_p_dot_one != None or hgvs_transcript.refseq_transcript.startswith('NR_')
        
        if hgvs_transcript.hgvs_p_dot_one != annovar_transcript.hgvs_p_dot_one:
            self.logger.debug(f"HGVS and Annovar do not agree on hgvs_p_dot_one for {transcript_key}: {hgvs_transcript.hgvs_p_dot_one} != {annovar_transcript.hgvs_p_dot_one} ")
    
        if self._allow_merge(new_transcript.hgvs_p_dot_one, hgvs_transcript.hgvs_p_dot_one, transcript_key, 'hgvs_p_dot_one'):
            new_transcript.hgvs_p_dot_one = hgvs_transcript.hgvs_p_dot_one
    
        # p-dot (3L)
        assert hgvs_transcript.hgvs_p_dot_three != None or hgvs_transcript.refseq_transcript.startswith('NR_')
    
        if hgvs_transcript.hgvs_p_dot_three != annovar_transcript.hgvs_p_dot_three:
            self.logger.debug(f"HGVS and Annovar do not agree on hgvs_p_dot_three for {transcript_key}: {hgvs_transcript.hgvs_p_dot_three} != {annovar_transcript.hgvs_p_dot_three} ")
    
        if self._allow_merge(new_transcript.hgvs_p_dot_three, hgvs_transcript.hgvs_p_dot_three, transcript_key, 'hgvs_p_dot_three'):
            new_transcript.hgvs_p_dot_three = hgvs_transcript.hgvs_p_dot_three
        
        # Splice variant indicator
        ## HGVS never tells us that a variant/transcript is involved in splicing. But Annovar does. 
        assert hgvs_transcript.splicing == None
        if self._allow_merge(new_transcript.splicing, annovar_transcript.splicing, transcript_key, 'splicing'):
            new_transcript.splicing = annovar_transcript.splicing
    
        # Refseq Transcript
        assert hgvs_transcript.refseq_transcript == annovar_transcript.refseq_transcript
        if self._allow_merge(new_transcript.refseq_transcript, annovar_transcript.refseq_transcript, transcript_key, 'refseq_transcript'):
            new_transcript.refseq_transcript = annovar_transcript.refseq_transcript
            
        # Variant Effect 
        ## variant effect is only provided by Annovar, and the value may be empty
        assert hgvs_transcript.variant_effect == None
        if self._allow_merge(new_transcript.variant_effect, annovar_transcript.variant_effect, transcript_key, 'variant_effect'):
            new_transcript.variant_effect = annovar_transcript.variant_effect
        
        # Variant Type 
        ## Variant type is only provided by Annovar, and the value will be empty in the case of splice variants. 
        assert hgvs_transcript.variant_type == None
    
        # Non-splicing transcripts from annovar are expected to have a variant type (ie exonic, intronic)
        if not annovar_transcript.splicing:
            assert self._noneIfEmpty(annovar_transcript.variant_type) != None, f'Variant type must not be empty for non-splicing transcripts. See {transcript_key}'
    
        if self._allow_merge(new_transcript.variant_type, annovar_transcript.variant_type, transcript_key, 'variant_type'):
            new_transcript.variant_type = annovar_transcript.variant_type 
         
        # Protein Transcript
        ## Only HGVS provides protein transcript
        assert hgvs_transcript.protein_transcript != None or hgvs_transcript.refseq_transcript.startswith('NR_')
        if self._allow_merge(new_transcript.protein_transcript, hgvs_transcript.protein_transcript, transcript_key, 'protein_transcript'):
            new_transcript.protein_transcript = hgvs_transcript.protein_transcript
        
        return new_transcript
    
    def _allow_merge(self, existing_value, new_value, variant_id, field_name):
        '''
        The merge functions in this script combine values from the HGVS UTA database with one, and sometimes two Annovar records. Once a value is 
        added to the new "merged" record, we don't want to overwrite that value with a different value. This step is just to make sure that 
        out assumptions about incoming data are correct.    
        '''
        if existing_value and new_value and existing_value != new_value:
            # The existing value has already been set and the incoming value is non-empty, and the two values are different
            raise Exception(f"Unexpected merge condition for {variant_id}: existing {field_name} value does not match new value: {existing_value} != {new_value}")
        elif existing_value != None and not new_value:
            # Don't overwrite a valid value with an empty value
            return False
        else:
            return True
    
    def get_summary(self, annovar_transcripts: list, annovar_variants: set, hgvs_transcripts: list, merged_transcripts: list, best_transcripts: list):
        '''
        Return a collection of summary statistics after processing completes. 
        '''
        results = dict()
        results['annovar_transcript_count'] = len(annovar_transcripts)
        results['annovar_distinct_variant_count'] = len(annovar_variants)
        results['hgvs_transcript_count'] = len(hgvs_transcripts)
        results['best_transcripts'] = len(best_transcripts)
        
        results['hgvs_distinct_variant_count'] = len(set(map(lambda x: Variant(x.chromosome, x.position, x.reference, x.alt), hgvs_transcripts)))
        
        # Collect annovar records into a map keyed by genotype and transcript
        annovar_dict = defaultdict(list)
         
        annovar_splice_variant_transcript_count = 0
        
        # Collect annovar records into a map keyed by genotype and transcript
        for annovar_rec in annovar_transcripts:
            if annovar_parser.is_annovar_splicing_type(annovar_rec.splicing):
                annovar_splice_variant_transcript_count += 1
            elif annovar_rec.splicing != None and annovar_rec.splicing != '':
                self.logger.warning(f"Invalid value in splicing column: {annovar_rec.splicing}")
    
            annovar_dict[annovar_rec.get_label()].append(annovar_rec)
        
        results['annovar_splice_variant_transcript_count'] = annovar_splice_variant_transcript_count
        
        # Collect hgvs records into a map keyed by genotype and transcript    
        hgvs_dict = defaultdict(list)
        for hgvs_rec in hgvs_transcripts:
            hgvs_dict[hgvs_rec.get_label()].append(hgvs_rec)
        
        # Collect merged hgvs and annovar recoreds into a map keyed by genotype and transcript
        merged_dict = defaultdict(list)
        for merged_rec in merged_transcripts:
            merged_dict[merged_rec.get_label()].append(merged_rec)
        
        matched_annovar_and_hgvs_transcript_count = 0
        unmatched_annovar_transcript_count = 0
        unmatched_hgvs_transcript_count = 0
    
        all_transcript_keys = set()
        all_transcript_keys.update(annovar_dict.keys())
        all_transcript_keys.update(hgvs_dict.keys())
         
        for transcript_key in all_transcript_keys:
            if annovar_dict.get(transcript_key) and hgvs_dict.get(transcript_key):
                matched_annovar_and_hgvs_transcript_count += 1
            elif annovar_dict.get(transcript_key) and not hgvs_dict.get(transcript_key):
                unmatched_annovar_transcript_count += 1
            elif hgvs_dict.get(transcript_key) and not annovar_dict.get(transcript_key):
                unmatched_hgvs_transcript_count += 1
            else:
                raise Exception("Unexpected summary condition")
        
        results['matched_annovar_and_hgvs_transcript_count'] = matched_annovar_and_hgvs_transcript_count
        results['unmatched_annovar_transcript_count'] = unmatched_annovar_transcript_count
        results['unmatched_hgvs_transcript_count'] = unmatched_hgvs_transcript_count    
        results['merged_transcript_count'] = len(merged_transcripts)
        
        
        merged_distinct_variant_count = len(set(map(lambda x: Variant(x.chromosome, x.position, x.reference, x.alt), merged_transcripts)))
        results['merged_distinct_variant_count'] = merged_distinct_variant_count 
        
        # Sanity check: The number of HGVS transcripts minus the count of merged HGVS transcripts is equal to the number of merged HGVS and annovar transcripts.    
        sanity_check_hgvs = (len(hgvs_transcripts) - unmatched_hgvs_transcript_count) == matched_annovar_and_hgvs_transcript_count
        if not sanity_check_hgvs:
            self.logger.debug(f"Failed sanity check 'sanity_check_hgvs': {len(hgvs_transcripts)} - {unmatched_hgvs_transcript_count} != {matched_annovar_and_hgvs_transcript_count}")
        
        # These sanity checks have not been maintained. The should probably be deleted and replaced with unit tests.  
        
        # Sanity check: The number of annovar transcripts minus the count of merged annovar transcripts is equal to the number of 
        # merged HGVS and annovar transcripts.
        sanity_check_annovar = (len(annovar_transcripts) - unmatched_annovar_transcript_count) == matched_annovar_and_hgvs_transcript_count    

        if not sanity_check_annovar:
            self.logger.debug(f"Failed Annovar sanity check: {len(annovar_transcripts)} - {unmatched_annovar_transcript_count} != {matched_annovar_and_hgvs_transcript_count}")
    
        # Essential sanity check:  
        if not sanity_check_hgvs or not sanity_check_annovar:
            self.logger.info(f'Failed sanity check: Total number of transcripts does not equal sum of matched, and unmatched ({sanity_check_hgvs} and {sanity_check_annovar}).')

        sanity_check = sanity_check_hgvs and sanity_check_annovar
        results['sanity_check'] = sanity_check
    
        return results
    
    def _log_summary(self, results: dict):
        '''
        Display summary of updated transcripts
        ''' 
        self.logger.info(f"Number of distinct variants from Annovar: {results['annovar_distinct_variant_count']}")    
        self.logger.info(f"Number of annovar transcripts: {results['annovar_transcript_count']}")
        self.logger.info(f"Number of Annovar transcripts that are splice variants: {results['annovar_splice_variant_transcript_count']}")    
        self.logger.info(f"Number of HGVS transcripts: {results['hgvs_transcript_count']}")
        self.logger.info(f"Number of distinct variants from HGVS: {results['hgvs_distinct_variant_count']}")
        self.logger.info(f"Number of transcripts matched in Annovar and HGVS: {results['matched_annovar_and_hgvs_transcript_count']}")
        self.logger.info(f"Number of Annovar transcripts not matched with HGVS transcripts: {results['unmatched_annovar_transcript_count']}")
        self.logger.info(f"Number of HGVS transcripts not matched with Annovar transcripts: {results['unmatched_hgvs_transcript_count']}")
        self.logger.info(f"Number of distinct variants in merged transcript list: {results['merged_distinct_variant_count']}")
        self.logger.info(f"Number of best transcripts in final list: {results['best_transcripts']}")
        self.logger.info(f"Sanity check: {'Passed' if results['sanity_check'] else 'Failed' }")
        
    def get_updated_hgvs_transcripts(self, annovar_transcripts: list, pysam_file):
        '''
        Take a list of transcripts from Annovar and use them to look up the corresponding variants using the HGVS python lib; and then 
        merge the annovar and hgvs info and return the results. 
        '''
        disinct_variants = {Variant(x.chromosome, x.position, x.reference, x.alt) for x in annovar_transcripts}
        
        self.logger.debug(f'{len(disinct_variants)} distinct variants')

        # Lookup the variant in the HGVS/UTA database
        hgvs_transcripts = self._lookup_hgvs_transcripts(disinct_variants, pysam_file)
        self.logger.debug(f'Received {len(hgvs_transcripts)} transcripts from HGVS')
        
        # Merge Annovar and HGVS/UTA transcripgs
        merged_transcripts, unmerged_transcripts = self._merge_annovar_with_hgvs(annovar_transcripts, hgvs_transcripts)
        self.logger.debug(f"Merged {len(merged_transcripts)} Annovar and HGVS transcripts")
        self.logger.debug(f"Found {len(unmerged_transcripts)} unmerged transcripts")
    
        all_transcripts = merged_transcripts + unmerged_transcripts
        
        # Because we have two sources of transcripts (annovar and hgvs/uta) we may have more than one version of a transcript but we only want one
        # version of each transcript.
        best_transcripts = self._get_the_best_transcripts(all_transcripts)
        
        self._log_summary(self.get_summary(annovar_transcripts, 
                                 disinct_variants, 
                                 hgvs_transcripts, 
                                 merged_transcripts,
                                 best_transcripts))
    
        
        return best_transcripts
            
    def __get_variant_transcript_key(self, transcript: VariantTranscript):
        '''
        This function returns a unique key that is used for a dict in the _get_the_best_transcripts function.
        The key looks like '7-12345-C-G-NM_123' (the transcript's version is not included) 
        '''
        # Take the version off of the transcript
        unversioned_transcript = transcript.refseq_transcript.split('.')[0]
        return f"{transcript.chromosome}-{transcript.position}-{transcript.reference}-{transcript.alt}-{unversioned_transcript}"
            
    def _get_the_best_transcripts(self, transcripts: list):
        '''
        When there is more than one version of a transcript this method picks the best one so that we only end up with one version of each. 
        The best transcript will be the one with the most information (ie the least sparse). When there is a tie, the transcript with the most 
        recent version is selected.
        '''
        # Create a dict where the key is the variant genotype and the unversioned transcript; and the value is a list 
        # of all the transcripts with that prefix that are associated with that genotype. Example:
        # 1-1-A-C-NM_001 --> [ NM_001.1, NM001.2]
        # 1-1-C-T-NM_001 --> [ NM_002.2]
        # 2-2-C-G-NM_001 --> [ NM_003.1, NM003.2, NM_004.5]
        transcript_dict = defaultdict(list)
    
        for transcript in transcripts:        
            transcript_dict[self.__get_variant_transcript_key(transcript)].append(transcript)
        
        # Send each list of transcripts, that are grouped by genotype and transcript, to a function that returns the best one 
        best_transcripts = []
        for key in transcript_dict:
            #best_transcripts.append(__get_best_transcript(transcript_dict[key]))
            best_transcript = self.__get_best_transcript(transcript_dict[key])
            
            # Annovar doesn't provide a gene for introns and UTR so when that happens lookup the transcript in UTA to see if we can get a gene for it.    
            if best_transcript.hgnc_gene is None:
                best_transcript.hgnc_gene = self._get_gene_for_transcript(best_transcript.refseq_transcript)
                if best_transcript.hgnc_gene is not None:
                    self.logger.debug(f"Found gene for transcript {best_transcript}: {best_transcript.hgnc_gene}")
    
            best_transcripts.append(best_transcript)
        
        return best_transcripts    
        
    def __get_best_transcript(self, transcripts: list):
        '''
        Take a list of transcripts and return the one that has the most fields filled in. If there is a tie, return the one with the latest version.     
        '''
        # The VariantTranscript's ``__lt__`` function has been overloaded for the purpose of ranking the transcript based on how many non-null fields it has.  
        sorted_by_ascending_score = sorted(transcripts)
        
        # return the last item in the sorted list (the one with the highest score)
        return sorted_by_ascending_score[-1]
    
    def _get_gene_for_transcript(self, transcript_accession: str):
        '''
        Use the HGVS lib to lookup a transcript's gene in UTA. 
        ToDo: this method reconnects to UTA each time it is called. Performance can be improved by keeping the connection open.
        '''
        try:
            rec = self.hdp.get_tx_identity_info(transcript_accession)
        except HGVSDataNotAvailableError as e:
            # if the transcript isn't in uta it throws an exception rather than just returning null
            self.logger.info(str(e))
            rec = None
    
        if rec is not None:
            assert type(rec[6]) == str, "Index six in object returned by hdp.get_tx_identity_info is supposed to the gene."
            return rec[6]
        else:
            return None;

    def _benchmark_start(self, name):
        """
        If benchmarking is enabled, begin timing a function. 
        """
        if not self._benchmarking:
            return
        
        self._benchmarking.start(name)
    
    def _benchmark_stop(self, name):
        """
        If benchmarking is enabled, stop the timer for a function
        """
        if not self._benchmarking:
            return
        
        self._benchmarking.stop(name)
    
    def _benchmark_cancel(self):
        """
        If benchmarking is enabled, cancel the timer  
        """
        if not self._benchmarking:
            return
        
        self._benchmarking.cancel_last()

    def _log_hgvs_benchmarks(self, variant: Variant, cnt_transcripts):
        """
        Update the a log file with the results of the benchmarking performed during execution of multiple HGVS functions.
        """
        if not self._benchmarking:
            return
        
        for name in self._benchmarking.get_names():            
            self._benchmark_csv_writer.writerow([variant, name, cnt_transcripts, self._benchmarking.get_time_total(name), self._benchmarking.get_time_average(name)])
         
        # Clear the timers after each log
        self._benchmarking.clear()
