'''
Read file generated by tx_eff_annovar.py, update transcript information using HGVS, and write out a CSV file with variant transcript effects.

Created on Apr 20, 2022

@author: pleyte
'''

from collections import defaultdict, Counter
import csv
import itertools
import logging
from multiprocessing.dummy import Pool as ThreadPool
import os
from pathlib import Path
import re
import threading

import hgvs.assemblymapper
import hgvs.dataproviders.uta
from hgvs.exceptions import HGVSInvalidVariantError, HGVSUsageError, HGVSDataNotAvailableError, \
    HGVSInvalidIntervalError, HGVSUnsupportedOperationError
from hgvs.sequencevariant import SequenceVariant

from edu.ohsu.compbio.annovar import annovar_parser
from edu.ohsu.compbio.annovar.annovar_parser import AnnovarVariantFunction
from edu.ohsu.compbio.txeff.util import chromosome_map
from edu.ohsu.compbio.txeff.util.benchmarking import Benchmarking
from edu.ohsu.compbio.txeff.util.tx_eff_pysam import PysamTxEff
from edu.ohsu.compbio.txeff.variant import Variant
from edu.ohsu.compbio.txeff.variant_transcript import VariantTranscript

ASSEMBLY_VERSION = "GRCh37"

class RptHandler:
    """
    Handle coordinate changes due to repetitive sequences in both deletions and duplications.  HGVS requires
    alignment to the 3' side, whereas VCF is 5'.
    """
    def __init__(self, pysamtxeff: PysamTxEff, chrom: str, coord: int, allele: str):
        """
        Window search size given by self.size (from PysamTxEff).  Sequence constructed based on location of variant
        and given search window size.  FASTA alt contains the sequence at the position of the potential rpt seq,
        matching the allele size.
        :param pysamtxeff: Pysam faidx coordinate search object
        :param chrom: chromosome for search
        :param coord: coordinate for search
        :param allele: the allele that contains the potentially repetitive del or dup
        """
        self.pysamtxeff = pysamtxeff
        self.chrom = chrom
        self.coord = coord
        self.allele = allele[1:]
        self.size = self.pysamtxeff.size
        self.seq = self.pysamtxeff.faidx_query(self.chrom, self.coord)
        self.fasta_alt = self.seq[self.size + 1:self.size + len(self.allele) + 1]
        self.fasta_alt_next = self.seq[self.size + len(self.allele) + 1:self.size + len(self.allele) + len(self.allele) + 1]

    def check_rpt_status(self) -> bool:
        """
        Check to see if the del/dup allele and sequence at the current search position match.
        :return:
        """
        return self.allele == self.fasta_alt

    def check_rpt_status_dup(self) -> bool:
        """
        Check to see if the del/dup allele and sequence at the current search position match.
        :return:
        """
        return self.allele == self.fasta_alt_next

    def find_rpt_coords(self) -> (int, int):
        """
        Search for a repetitive allele in the reference, until there are no more.  Then return the start/stop
        coordinates associated with the updated 3' position.
        :return:
        """
        start_size = self.size
        end_size = self.size + len(self.allele)
        coord = self.coord + 1
        fasta_alt = self.fasta_alt
        while self.allele == fasta_alt:
            coord += len(self.allele)
            start_size += len(self.allele)
            end_size += len(self.allele)
            fasta_alt = self.seq[start_size:end_size]
        new_start = coord - len(self.allele)
        new_end = new_start + len(self.allele) - 1
        return new_start, new_end
        
class TxEffHgvs(object):
    """
    Finds transcripts associated with variant. Makes use of the SeqRepo and UTA datasources. 
    Benchmarking can be enabled to produce a csv file that shows how long SeqRepo and UTA queries are taking.
    pysam is an instance of PysamTxEff
    refseq_ccds_map is the dict created by TxEffCcds
    """ 
    def __init__(self, pysam, refseq_ccds_map, sequence_source = None, threads = 1, benchmark = False):
        self.logger = logging.getLogger(__name__)
        self._pysam = pysam
        self._sequence_source = sequence_source
        self._benchmarking = None
        self._variant_counter = 0
        
        self._ccds_map_counter = Counter()
        self._refseq_ccds_map = refseq_ccds_map
        
        # Fields related to threaded processing
        self._lock = threading.Lock()
        self._threads = threads
        
        # Setup benchmarking if it is requested
        if benchmark:
            self._benchmarking = Benchmarking()

            self._benchmark_file = open("benchmark.csv", 'w')
            self.logger.info(f"Benchmarking enabled. Writing to {self._benchmark_file.name}") 
            self._benchmark_csv_writer = csv.writer(self._benchmark_file)
            self._benchmark_csv_writer.writerow(['variant_number', 'variant', 'name', 'transcript_count', 'total_time', 'average_time'])
 
    def __enter__(self):
        '''
        Open database connection  
        '''        
        # Configure biocommons-hgvs to use the SeqRepo rest service, file repository, or the the NCBI api.
        self._configure_sequence_source()

        # Initialize the UTA database connection        
        self._configure_uta()

        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.logger.debug("Closing UTA connection")
        self.hdp.close()
        
        if self._benchmarking:
            self._benchmark_file.close() 

    def _configure_uta(self):
        self.logger.debug("Opening UTA connection")
        
        if not os.environ.get('UTA_DB_URL'):
            # This option won't work from within OHSU's network because they seem to block us.  
            self.logger.warning("The UTA_DB_URL environment variable is not defined. The remote public postgresql database at uta.biocommons.org will be used.")
        else:
            # This leaks the password. Consider splitting the string: postgresql://name:password@host:5432/uta/uta_20210129
            self.logger.info(f"Using UTA Database at {os.environ.get('UTA_DB_URL')}")

        # Initialize the HGVS connection        
        self.hdp = hgvs.dataproviders.uta.connect()
        self.am = hgvs.assemblymapper.AssemblyMapper(self.hdp, assembly_name=ASSEMBLY_VERSION, alt_aln_method='splign')
        self.hgvs_parser = hgvs.parser.Parser()      
          
    def _configure_sequence_source(self):
        """
        The biocommons-hgvs module needs a way to lookup reference sequences. There are three options:
        * Use local SeqRepo installation
            - This is the most performant solution when SeqRepo is installed on the same host as Transcript Effects running. 
            - SeqRepo files are too large be be opened over a network file system.
            - To use this method set the environment variable HGVS_SEQREPO_DIR with the path to the SeqRepo installation.    
        * Use SeqRepo REST API to query a remote SeqRepo installation
            - In production Transcript Effects runs on a Galaxy node and we access SeqRepo using the SeqRepo REST service. 
            - To use this method set the environment variable HGVS_SEQREPO_URL with the url of the SeqRepo service.  
        * Use NCBI's E-Utilties API instead of SeqRepo
            - Instead of using SeqRepo, biocommons-hgvs can lookup sequences using NCBI's E-Utilities API. 
            - To use this method use you create an NCBI account, generate an API key and set it in the NCBI_API_KEY environment variable. 
            - This option works great but we have not investigated its dependability as a production resource.      
        
        The KCC Galaxy instances define the HGVS_SEQREPO_DIR environment variable. But it is on a networked file system. If you add 
        HGVS_SEQREPO_URL to the environment, biocommons-hgvs will still use the file repository so it is necessary to unset
        HGVS_SEQREPO_DIR when we want to use the SeqRepo REST service.
        
        This function sets up the environment prioritizing the sequence options the order:
        0. The method specified by the optional sequence_source parameter in the constructor. 
        1. The SeqRepo REST service found in the HGVS_SEQREPO_URL environment variable
        2. The SeqRepo file repository found in the HGVS_SEQREPO_DIR environment variable. 
        3. NCBI E-Utilities when none of the above are spefified. 
        """
        self.logger.debug("Determining SeqRepo repository location")
        
        env_seqrepo_url = os.environ.get('HGVS_SEQREPO_URL')
        env_seqrepo_directory = os.environ.get('HGVS_SEQREPO_DIR')
        
        # If they want to use ncbi then the other two options have to be disabled
        if self._sequence_source == 'ncbi' \
           or (not self._sequence_source and not env_seqrepo_url and not env_seqrepo_directory):

            self.logger.info("Reference sequences will be retrieved using NCBI's E-Utilities API")
            self.logger.warning("The NCBI API should only be used for testing. Do not use it in a production environment.")
            
            if os.environ.get('NCBI_API_KEY'):
                self.logger.info(f"NCBI API Key is present: {os.environ.get('NCBI_API_KEY')}")
            else:
                # The n queries per second limit will cause delays and possibly failure  
                self.logger.warning("Using NCBI's E-Utilities without an NCBI API Key is discouraged")

            os.environ.pop('HGVS_SEQREPO_DIR', None)
            os.environ.pop('HGVS_SEQREPO_URL', None)
            return 1
        
        # Default is to prioritize the service over the file repository 
        if not self._sequence_source and env_seqrepo_url:
            if not env_seqrepo_url.lower().startswith('http'):
                self.logger.warning("The SeqRepo service is requested but the URL appears invalid: " + env_seqrepo_url)
            else: 
                self.logger.info("Reference sequences will be retrieved using the SeqRepo service: " + env_seqrepo_url)
            
            # Remove HGVS_SEQREPO_DIR from environment since biocommons.hgvs prioritizes it over the SeqRepo service.
            os.environ.pop('HGVS_SEQREPO_DIR', None)
            return 2
                
        if not self._sequence_source and env_seqrepo_directory:
            if not Path(env_seqrepo_directory).is_dir():
                self.logger.warning("The SeqRepo file repository is requested but the path appears invalid: " + env_seqrepo_directory)
            else:
                self.logger.info("Reference sequences will be retrieved using the SeqRepo file repository: " + env_seqrepo_directory)
            
            os.environ.pop('HGVS_SEQREPO_URL', None)
            return 3
        
        # If the sequence parameter is a URL then the SeqRepo service will be used. 
        if self._sequence_source and self._sequence_source.lower().startswith('http'):
            self.logger.info("Reference sequences will be retrieved using the SeqRepo service: " + self._sequence_source)
            os.environ['HGVS_SEQREPO_URL'] = self._sequence_source
            os.environ.pop('HGVS_SEQREPO_DIR', None)
            return 4
        
        if self._sequence_source and self._sequence_source.startswith("/"):
            if not Path(self._sequence_source).is_dir():
                self.logger.warning("The SeqRepo file repository is requested but the path appears invalid: " + self._sequence_source)
            else:
                self.logger.info("Reference sequences will be retrieved using the SeqRepo file repository: " + self._sequence_source)
            
            os.environ['HGVS_SEQREPO_DIR'] = self._sequence_source
            os.environ.pop('HGVS_SEQREPO_URL', None)
            return 5
        
        raise ValueError("The sequence_source parameter must be a url, a directory, or 'ncbi': " + self._sequence_source)

    def _correct_indel_coords(self, chrom, pos, ref, alt):
        """
        Using a VCF position, create coords that are compatible with HGVS nomenclature.
        Since we are already determining at this stage whether the event is an ins or del, also
        include the ins or del strings in the result.
        substitution event -> ac:g.[pos][ref]>[alt]
        :return:
        """
        lref = len(ref)
        lalt = len(alt)
        if lref == 1 and lalt == 1:
            # Substitution case
            change = '>'.join([ref, alt])
            new_pos = str(pos) + change
            return new_pos
        elif lalt == 1 and lref > lalt:
            dels = RptHandler(self._pysam, chrom, pos, ref)
            # Deletion case
            if dels.check_rpt_status():
                new_start, new_end = dels.find_rpt_coords()
                if len(dels.allele) == 1:
                    new_pos = '_'.join([str(new_start - 1)]) + 'del'
                else:
                    new_pos = '_'.join([str(new_start), str(new_end)]) + 'del'
            else:
                shift = lref - lalt
                if shift == 1:
                    new_pos = str(int(pos) + 1) + 'del'
                else:
                    new_start = str(int(pos) + 1)
                    new_end = str(int(pos) + shift)
                    new_pos = '_'.join([new_start, new_end]) + 'del'
            return new_pos
        elif lref == 1 and lalt > lref:
            dups = RptHandler(self._pysam, chrom, pos, alt)
            # Duplication case
            if dups.check_rpt_status():
                new_start, new_end = dups.find_rpt_coords()
                # Check if there is a padding base, then adjust accordingly.
                if alt[0] == ref[0]:
                    new_start -= 1
                    new_end -= 1
                if len(dups.allele) == 1:
                    new_pos = '_'.join([str(new_start)]) + 'dup'
                else:
                    if dups.check_rpt_status_dup():
                        new_pos = '_'.join([str(new_start + len(dups.allele)), str(new_end + len(dups.allele))]) + 'dup'
                    else:
                        new_pos = '_'.join([str(new_start + 1), str(new_end + 1)]) + 'dup'

            # Insertion case
            else:
                new_start = str(pos)
                new_end = str(int(pos) + 1)
                new_pos = '_'.join([new_start, new_end]) + 'ins' + alt[1:]
            return new_pos
        elif lref > 1 and lalt > 1:
            # Multi-nucleotide substitution case
            # NG_012232.1: g.12_13delinsTG
            new_start = pos
            new_end = str(int(pos) + lref - 1)
            # If there is a common padding base, like ATG>ACC, make sure we are taking this in to account.
            if alt[0] == ref[0]:
                new_start += 1
                alt = alt[1:]
            new_pos = '_'.join([str(new_start), new_end]) + 'delins' + alt
            return new_pos
        else:
            raise Exception("Unknown change type: " + pos + ':' + ref + '>' + alt)

    def _lookup_hgvs_transcripts(self, variants: list):
        '''
        Return the HGVS transcripts associated with a list of variants  
        '''
        pool = ThreadPool(processes = self._threads)
        
        # One thread per variant 
        results = pool.map(self._lookup_variant_hgvs_transcripts, variants)
        
        pool.close()
        pool.join()
        
        # The results from pool.map is a list of lists where each index is the list of transcripts for one variant. 
        # itertools flattens the results into a single list of all transcripts for all variants. 
        return list(itertools.chain.from_iterable(results))                        
        
    def _lookup_variant_hgvs_transcripts(self, variant: Variant):
        '''
        Use HGVS/UTA to return a list of the transcripts for a variant
        '''
        self._increment_variant_counter()

        # Even the numeric chromosomes need to be strings in order to be found in the chromosome map
        assert type(variant.chromosome) == str 

        refseq_chromosome = chromosome_map.get_refseq(variant.chromosome)
        
        # Look up the variant using HGVS
        pos_part = self._correct_indel_coords(variant.chromosome, variant.position, variant.reference, variant.alt)
        new_hgvs = refseq_chromosome + ':g.' + pos_part
    
        var_g = self.hgvs_parser.parse_hgvs_variant(new_hgvs)
    
        # Retrieve transcripts that are in a genomic region
        self._benchmark_start('hdp.get_tx_for_region (UTA)')
        tx_list = self.hdp.get_tx_for_region(str(var_g.ac), 'splign', var_g.posedit.pos.start.base, var_g.posedit.pos.end.base)
        self._benchmark_stop('hdp.get_tx_for_region (UTA)')

        hgvs_transcripts = []
        
        for uta_row in tx_list:
            refseq_transcript = uta_row[0]
            refseq_chromosome = uta_row[1]

            try:
                variant_transcript = VariantTranscript(variant.chromosome, variant.position, variant.reference, variant.alt)
    
                variant_transcript.sequence_variant = self.__to_g_dot(var_g)
                
                # Annovar doesn't provide a gene for UTR and introns, so in those cases the gene information comes from HGVS using this function.
                self._benchmark_start('hdp.get_tx_info (UTA)')
                transcript_detail = self.hdp.get_tx_info(refseq_transcript, refseq_chromosome, 'splign')
                variant_transcript.hgnc_gene = transcript_detail['hgnc']
                self._benchmark_stop('hdp.get_tx_info (UTA)')
                
                # Determine c. and p.. Non coding transcripts will throw an error. See HGVSUsageError caught below.
                self._benchmark_start('am.g_to_c (SeqRepo)') 
                var_c = self.am.g_to_c(var_g, str(refseq_transcript))
                self._benchmark_stop('am.g_to_c (SeqRepo)')

                self._benchmark_start('am.c_to_p (SeqRepo)') 
                var_p = self.am.c_to_p(var_c)
                self._benchmark_stop('am.c_to_p (SeqRepo)')
                
                # setting uncertain to False removes the parentheses on the stringified form
                if var_p.posedit:
                    var_p.posedit.uncertain = False
    
                # Convert the three letter amino acid seq to a one letter and remove the 'transcript:' prefix.             
                var_p1 = var_p.format(conf={"p_3_letter": False}).replace(var_p.ac+':','')
                var_p3 = var_p.format(conf={"p_3_letter": True}).replace(var_p.ac+':','')
    
                # Correct bug in biocommons/hgvs lib that always returns the three letter amino acid when variant is start loss. 
                if var_p1 == 'p.Met1?':
                    var_p1 = 'p.M1?'
    
                c_dot = var_c.type +'.' + str(var_c.posedit)
                
                # HGVS doesrn't provide a variant type. 
                variant_type = None
                
                # The amino acid position only exists for certain types of variants.             
                if var_p3 == 'p.?' and var_p.posedit:
                    self.logger.warning(f"A position is not expected with 'p.?': {variant}, pos={var_p.posedit}")
                elif isinstance(var_p.posedit, hgvs.edit.AARefAlt):
                    # Some variants don't have any position information, and that is ok. Most of the time these are indels, as indicated by ``var_p.posedit.type``
                    self.logger.debug(f"HGVS variant does not have a position: ref={var_p.posedit.ref}, alt={var_p.posedit.alt}, type={var_p.posedit.type}, str={str(var_p.posedit)}. Keeping.")                    
                elif var_p.posedit:
                    variant_transcript.hgvs_amino_acid_position = var_p.posedit.pos.start.pos

                variant_transcript.hgvs_base_position = var_c.posedit.pos.start.base
                
                variant_transcript.hgvs_c_dot = c_dot
                variant_transcript.hgvs_p_dot_one = var_p1
                variant_transcript.hgvs_p_dot_three = var_p3
                variant_transcript.refseq_transcript = var_c.ac
                variant_transcript.variant_type = variant_type
    
                # Sometimes the am.c_to_p function returns the protein accession as an MD5 hash 
                # of the amino acid sequence (see uta.get_acs_for_protein_seq)
                if not var_p.ac.startswith('MD5'):
                    variant_transcript.protein_transcript = var_p.ac
    
                # Data validation. We'd like to know how often this happens.
                if (variant_transcript.hgvs_p_dot_one or variant_transcript.hgvs_p_dot_three) and not variant_transcript.protein_transcript:
                    self.logger.warning(f"A protein transcript is expected when there is a p.: {variant}, p1={variant_transcript.hgvs_p_dot_one}, p3={variant_transcript.hgvs_p_dot_three}, pt={variant_transcript.protein_transcript}")                     
                if (variant_transcript.hgvs_p_dot_one and not variant_transcript.hgvs_p_dot_three) or (variant_transcript.hgvs_p_dot_three and not variant_transcript.hgvs_p_dot_one):
                    self.logger.warning(f"Both p1 and p3 are expected: {variant}, p1={variant_transcript.hgvs_p_dot_one}, p3={variant_transcript.hgvs_p_dot_three}, pt={variant_transcript.protein_transcript}")
                if variant_transcript.protein_transcript and (not variant_transcript.hgvs_p_dot_one or not variant_transcript.hgvs_p_dot_three): 
                    self.logger.warning(f"Protein genotypes are expected when a there is a protein transcript: {variant}, p1={variant_transcript.hgvs_p_dot_one}, p3={variant_transcript.hgvs_p_dot_three}, pt={variant_transcript.protein_transcript}")

                hgvs_transcripts.append(variant_transcript)
    
            except HGVSUsageError as e:
                if("non-coding transcript" in str(e)):
                    self.logger.info(f"Encountered non-coding transcript {variant}. Transcript will be ignored: %s", str(e))
                    self._benchmark_cancel()
                else:
                    raise(e)
            except HGVSInvalidVariantError as e:            
                self.logger.warning(f"Invalid variant {variant}: %s", str(e))
                raise(e)
            except HGVSUnsupportedOperationError as e:
                self.logger.warning(f"Invalid parameters while processing variant {variant}, var_g={var_g}, transcript={refseq_transcript}: %s", str(e))
                self._benchmark_cancel()
            except HGVSInvalidIntervalError as e:
                self.logger.warning(f"Invalid variant interval {variant}: %s", str(e))
                self._benchmark_cancel()
            except HGVSDataNotAvailableError as e:
                # HGVS throws HGVSDataNotAvailableError for unrecoverable connection errors, and for when a row in the database just wasn't found.
                # If the RefSeq transcript prefix isn't NM (eg NM_123.3) then it is a transcript type we aren't interested in (eg NR, NP, XM, XR, XP). So we skip
                # the transcript and continue iterating.
                if not re.match('^NM_[0-9]+\.[0-9]+$', refseq_transcript):
                    self.logger.warning(f"Unable to find transcript '{refseq_transcript}': {str(e)})")
                    self._benchmark_cancel()
                elif 'alignment' in str(e).lower():
                    self.logger.info(f"HGVS alignment not found while parsing variant {variant} (see https://hgvs.readthedocs.io/en/stable/faq.html): %s", str(e))
                    self._benchmark_cancel()
                else:
                    self.logger.error(f"Error while parsing variant {variant}: %s", str(e))
                    raise(e)
            except NotImplementedError as e:
                self.logger.warning(f"Invalid CDS sequence while processing variant {variant}: %s", str(e))
                self._benchmark_cancel()

        self.logger.debug(f"HGVS found {len(hgvs_transcripts)} transcripts for {variant}")        
        
        # HGVS might not find any transcripts even though Annovar did 
        if len(hgvs_transcripts) == 0: 
            self.logger.info(f'HGVS could not find any transcripts for variant {variant} which has transcripts known to Annovar.')

        # Update the benchmarking log after processing each variant
        self._log_hgvs_benchmarks(variant, len(hgvs_transcripts))

        return hgvs_transcripts
    
    def __to_g_dot(self, var_g: SequenceVariant):
        '''
        Convert the SequenceVariant object to a g-dot. The string 'NC_000002.11:g.48033742_48033759dup' is split and just the g. is returned.  
        '''
        return str(var_g).split(':')[1]
    
    def _get_unmatched_annovar_transcripts(self, annovar_dict: defaultdict(AnnovarVariantFunction), hgvs_dict: defaultdict(VariantTranscript)):
        '''
        After HGVS and Annovar transcripts have been merged, this function is called to find Annovar transcripts that were not paired 
        with an HGVS trancsript. The parameters to the function are dictionaries because that facilitates quickly looking for 
        transcripts having the same genotype. 
        '''
        transcripts = []
        
        # Iterate through the annovar transcripts and see if any are in the hgvs list
        for (transcript_key, annovar_transcript) in annovar_dict.items():
            # Check the HGVS dictionary for a key matching the annovar key. If there is a match, then the annovar transcript has already  
            # been processed. If HGVS does not have the key then the annovar transcript has not been looked at.
            if not hgvs_dict.get(transcript_key):
                self.logger.debug(f"Adding unmatched Annovar transcript(s) for {transcript_key}")
                
                # Convert the AnnovarVariantFunction objects to VariantTranscript so all items in the list are of the VariantTranscript type. 
                transcripts.append(self.to_variant_transcript(annovar_transcript))
        
        # Iterate through the hgvs transcripts and see if any of them are in the annovar list
        for (transcript_key, hgvs_transcript) in hgvs_dict.items():
            if not annovar_dict.get(transcript_key):
                self.logger.debug(f"Adding unmatched HGVS transcript(s) for {transcript_key}")
                transcripts.append(hgvs_transcript)
        
        return transcripts
    
    def to_variant_transcript(self, annovar_transcript: AnnovarVariantFunction):
            '''
            Create a new VariantTranscript using the values from an object of parent type AnnovarVariantFunction
            '''
            variant_transcript = VariantTranscript(annovar_transcript.chromosome, annovar_transcript.position, annovar_transcript.reference, annovar_transcript.alt)
            variant_transcript.protein_transcript = None
            variant_transcript.variant_effect = annovar_transcript.variant_effect
            variant_transcript.variant_type = annovar_transcript.variant_type
            variant_transcript.hgvs_amino_acid_position = annovar_transcript.hgvs_amino_acid_position
            variant_transcript.hgvs_base_position = annovar_transcript.hgvs_base_position
            variant_transcript.exon = annovar_transcript.exon
            variant_transcript.hgnc_gene = annovar_transcript.hgnc_gene
            variant_transcript.hgvs_c_dot = annovar_transcript.hgvs_c_dot
            variant_transcript.hgvs_p_dot_one = annovar_transcript.hgvs_p_dot_one
            variant_transcript.hgvs_p_dot_three = annovar_transcript.hgvs_p_dot_three
            variant_transcript.splicing = annovar_transcript.splicing
            variant_transcript.refseq_transcript = annovar_transcript.refseq_transcript
            return variant_transcript
            
    def _merge_annovar_with_hgvs(self, annovar_transcripts: list, hgvs_transcripts: list):
        '''
        Given a list of transcripts from Annovar and HGVS, find those with the same genotype and transcript, and merge them into a single record.
        '''
        merged_transcripts = []
    
        # Collect annovar records into a map keyed by genotype and transcript 
        annovar_dict = defaultdict(VariantTranscript)
        for annovar_rec in annovar_transcripts:
            annovar_key = annovar_rec.get_label()
            assert annovar_key not in annovar_dict, f'A matching annovar variant-transcript should not already be in the dictionary: {annovar_rec.get_label()}'          
            annovar_dict[annovar_key] = annovar_rec
    
        # Collect hgvs records into a map keyed by genotype and transcript    
        hgvs_dict = defaultdict(VariantTranscript)
        for hgvs_rec in hgvs_transcripts:
            assert hgvs_rec.get_label() not in hgvs_dict, f'A matching hgvs variant-transcript should not already be in the dictionary: {hgvs_rec.get_label()}'
            hgvs_dict[hgvs_rec.get_label()] = hgvs_rec
    
        # Iterate over every HGVS variant-transcript and see if there is a matching Annovar transcript
        for (transcript_key, hgvs_transcript) in hgvs_dict.items():
            annovar_match = annovar_dict.get(transcript_key) 
            if not annovar_match:
                self.logger.debug(f"HGVS {transcript_key} does not match any Annovar transcripts")
            else:
                self.logger.debug(f"Merging HGVS transcript with Annovar transcript having key {transcript_key}")
                merged_transcripts.append(self._merge(transcript_key, hgvs_transcript, annovar_match))
      
        unmerged_transcripts = self._get_unmatched_annovar_transcripts(annovar_dict, hgvs_dict)
    
        return merged_transcripts, unmerged_transcripts
    
    def _merge(self, transcript_key: str, hgvs_transcript: VariantTranscript, annovar_transcript: VariantTranscript):
        '''
        Combine Annovar and HGVS information relating to the same transcript into a single record.  
        '''
        new_transcript = VariantTranscript(hgvs_transcript.chromosome, hgvs_transcript.position, hgvs_transcript.reference, hgvs_transcript.alt)
    
        self._merge_into(transcript_key, new_transcript, hgvs_transcript, annovar_transcript)
            
        return new_transcript
    
    
    def _merge_into(self, transcript_key: str, new_transcript: VariantTranscript, hgvs_transcript: VariantTranscript, annovar_transcript: VariantTranscript):
        '''
        Take the best parts of the hgvs_transcript and the annovar_transcript, and place them in the new_transcript 
        '''
        assert hgvs_transcript.chromosome == annovar_transcript.chromosome, f"HGVS and Annovar genotype chromosomes are not equal: {hgvs_transcript.chromosome} != {annovar_transcript.chromosome}"
        assert hgvs_transcript.position == annovar_transcript.position, f"HGVS and Annovar genotype positions are not equal: {hgvs_transcript.position} != {annovar_transcript.position}"
        assert hgvs_transcript.reference == annovar_transcript.reference, f"HGVS and Annovar genotype references are not equal: {hgvs_transcript.reference} != {annovar_transcript.reference}"
        assert hgvs_transcript.alt == annovar_transcript.alt, f"HGVS and Annovar genotype alts are not equal: {hgvs_transcript.alt} != {annovar_transcript.alt}"
        
        # Amino Acid Position
        ## Use only the hgvs/uta value, annovar's is ignored.
        if self._allow_merge(new_transcript.hgvs_amino_acid_position, hgvs_transcript.hgvs_amino_acid_position, transcript_key, 'hgvs_amino_acid_position'):
            new_transcript.hgvs_amino_acid_position = hgvs_transcript.hgvs_amino_acid_position 
        
        # Base Position
        ## Base position may not match what HGVS says; can be empty; or will match between annovar and hgvs    
        if str(hgvs_transcript.hgvs_base_position) != str(annovar_transcript.hgvs_base_position):
            self.logger.debug(f"HGVS and Annovar do not agree on base_position for {transcript_key}: {hgvs_transcript.hgvs_base_position} != {annovar_transcript.hgvs_base_position}")    
        
        if self._allow_merge(new_transcript.hgvs_base_position, hgvs_transcript.hgvs_base_position, transcript_key, 'hgvs_base_position'):
            new_transcript.hgvs_base_position = hgvs_transcript.hgvs_base_position

        # Exon number
        ## Only Annovar provides exon, and the value may be empty.
        assert not hgvs_transcript.exon
        if self._allow_merge(new_transcript.exon, annovar_transcript.exon, transcript_key, 'exon'):
            new_transcript.exon = annovar_transcript.exon 

        # Gene
        # Prefer annovar's gene, but annovar doesn't give us a gene for intron and utr; in those cases use hgvs's.        
        transcript_gene = annovar_transcript.hgnc_gene
        if not annovar_transcript.hgnc_gene and not hgvs_transcript.hgnc_gene:
            self.logger.debug(f"Gene selection: Neither Annovar or HGVS have a gene for {transcript_key}") 
        elif not annovar_transcript.hgnc_gene:
            self.logger.debug(f"Gene selection: Annovar did not provide a gene for {transcript_key}, using HGVS's: gene={hgvs_transcript.hgnc_gene}")            
            transcript_gene = hgvs_transcript.hgnc_gene
        elif annovar_transcript.hgnc_gene != hgvs_transcript.hgnc_gene:
            self.logger.info(f"Gene selection: Annovar and HGVS genes don't match for {transcript_key}: {annovar_transcript.hgnc_gene} != {hgvs_transcript.hgnc_gene}")
        
        if self._allow_merge(new_transcript.hgnc_gene, transcript_gene, transcript_key, 'hgnc_gene'):
            new_transcript.hgnc_gene = transcript_gene
        
        # g-dot
        ## Always comes from hgvs/uta
        new_transcript.sequence_variant = hgvs_transcript.sequence_variant
    
        # c-dot
        ## Use HGVS's c. because Annovar's is not always correct. Non-coding transcripts don't have a c. 
        assert hgvs_transcript.hgvs_c_dot, "The HGVS c. value is not supposed to be empty"
        
        if hgvs_transcript.hgvs_c_dot != annovar_transcript.hgvs_c_dot:
            self.logger.debug(f"HGVS and Annovar do not agree on c_dot for {transcript_key}: {hgvs_transcript.hgvs_c_dot} != {annovar_transcript.hgvs_c_dot} ")
    
        if self._allow_merge(new_transcript.hgvs_c_dot, hgvs_transcript.hgvs_c_dot, transcript_key, 'hgvs_c_dot'):
            new_transcript.hgvs_c_dot = hgvs_transcript.hgvs_c_dot
        
        # p-dot (1L)
        ## Use only the hgvs/uta value, annovar's is ignored.
        ## Non-coding transcripts don't have a p.
        assert hgvs_transcript.hgvs_p_dot_one
        if self._allow_merge(new_transcript.hgvs_p_dot_one, hgvs_transcript.hgvs_p_dot_one, transcript_key, 'hgvs_p_dot_one'):
            new_transcript.hgvs_p_dot_one = hgvs_transcript.hgvs_p_dot_one
    
        # p-dot (3L)
        ## Use only the hgvs/uta value, annovar's is ignored.
        ## Non-coding transcripts don't have a p.
        assert hgvs_transcript.hgvs_p_dot_three    
        if self._allow_merge(new_transcript.hgvs_p_dot_three, hgvs_transcript.hgvs_p_dot_three, transcript_key, 'hgvs_p_dot_three'):
            new_transcript.hgvs_p_dot_three = hgvs_transcript.hgvs_p_dot_three
        
        # Splice variant indicator
        ## HGVS never tells us that a variant/transcript is involved in splicing. But Annovar does. 
        assert not hgvs_transcript.splicing
        if self._allow_merge(new_transcript.splicing, annovar_transcript.splicing, transcript_key, 'splicing'):
            new_transcript.splicing = annovar_transcript.splicing
    
        # Refseq Transcript
        assert hgvs_transcript.refseq_transcript == annovar_transcript.refseq_transcript
        if self._allow_merge(new_transcript.refseq_transcript, annovar_transcript.refseq_transcript, transcript_key, 'refseq_transcript'):
            new_transcript.refseq_transcript = annovar_transcript.refseq_transcript
            
        # Variant Effect 
        ## variant effect is only provided by Annovar, and the value may be empty
        assert not hgvs_transcript.variant_effect
        if self._allow_merge(new_transcript.variant_effect, annovar_transcript.variant_effect, transcript_key, 'variant_effect'):
            new_transcript.variant_effect = annovar_transcript.variant_effect
        
        # Variant Type 
        ## Variant type is only provided by Annovar, and the value will be empty in the case of splice variants. 
        assert not hgvs_transcript.variant_type
    
        # Non-splicing transcripts from annovar are expected to have a variant type (ie exonic, intronic)
        if not annovar_transcript.splicing:
            assert annovar_transcript.variant_type, f'Variant type must not be empty for non-splicing transcripts. See {transcript_key}'
    
        if self._allow_merge(new_transcript.variant_type, annovar_transcript.variant_type, transcript_key, 'variant_type'):
            new_transcript.variant_type = annovar_transcript.variant_type 
         
        # Protein Transcript
        ## Only HGVS provides protein transcript
        assert hgvs_transcript.protein_transcript
        if self._allow_merge(new_transcript.protein_transcript, hgvs_transcript.protein_transcript, transcript_key, 'protein_transcript'):
            new_transcript.protein_transcript = hgvs_transcript.protein_transcript
        
        return new_transcript
    
    def _allow_merge(self, existing_value, new_value, variant_id, field_name):
        '''
        The merge functions in this script combine values from the HGVS UTA database with one, and sometimes two Annovar records. Once a value is 
        added to the new "merged" record, we don't want to overwrite that value with a different value. This step is just to make sure that 
        out assumptions about incoming data are correct.    
        '''
        if existing_value and new_value and existing_value != new_value:
            # The existing value has already been set and the incoming value is non-empty, and the two values are different
            raise Exception(f"Unexpected merge condition for {variant_id}: existing {field_name} value does not match new value: {existing_value} != {new_value}")
        elif existing_value and not new_value:
            # Don't overwrite a valid value with an empty value
            return False
        else:
            return True
    
    def get_summary(self, annovar_transcripts: list, annovar_variants: set, hgvs_transcripts: list, merged_transcripts: list, refseq_transcripts: list, ccds_transcripts: list):
        '''
        Return a collection of summary statistics after processing completes. 
        '''
        results = dict()
        results['annovar_transcript_count'] = len(annovar_transcripts)
        results['annovar_distinct_variant_count'] = len(annovar_variants)
        results['hgvs_transcript_count'] = len(hgvs_transcripts)
        results['refseq_transcripts'] = len(refseq_transcripts)
        results['ccds_transcripts'] = len(ccds_transcripts)
        
        results['hgvs_distinct_variant_count'] = len(set(map(lambda x: Variant(x.chromosome, x.position, x.reference, x.alt), hgvs_transcripts)))
        
        # Collect annovar records into a map keyed by genotype and transcript
        annovar_dict = defaultdict(list)
         
        annovar_splice_variant_transcript_count = 0
        
        # Collect annovar records into a map keyed by genotype and transcript
        for annovar_rec in annovar_transcripts:
            if annovar_parser.is_annovar_splicing_type(annovar_rec.splicing):
                annovar_splice_variant_transcript_count += 1
            elif annovar_rec.splicing:
                self.logger.warning(f"Invalid value in splicing column: {annovar_rec.splicing}")
    
            annovar_dict[annovar_rec.get_label()].append(annovar_rec)
        
        results['annovar_splice_variant_transcript_count'] = annovar_splice_variant_transcript_count
        
        # Collect hgvs records into a map keyed by genotype and transcript    
        hgvs_dict = defaultdict(list)
        for hgvs_rec in hgvs_transcripts:
            hgvs_dict[hgvs_rec.get_label()].append(hgvs_rec)
        
        # Collect merged hgvs and annovar recoreds into a map keyed by genotype and transcript
        merged_dict = defaultdict(list)
        for merged_rec in merged_transcripts:
            merged_dict[merged_rec.get_label()].append(merged_rec)
        
        matched_annovar_and_hgvs_transcript_count = 0
        unmatched_annovar_transcript_count = 0
        unmatched_hgvs_transcript_count = 0
    
        all_transcript_keys = set()
        all_transcript_keys.update(annovar_dict.keys())
        all_transcript_keys.update(hgvs_dict.keys())
         
        for transcript_key in all_transcript_keys:
            if annovar_dict.get(transcript_key) and hgvs_dict.get(transcript_key):
                matched_annovar_and_hgvs_transcript_count += 1
            elif annovar_dict.get(transcript_key) and not hgvs_dict.get(transcript_key):
                unmatched_annovar_transcript_count += 1
            elif hgvs_dict.get(transcript_key) and not annovar_dict.get(transcript_key):
                unmatched_hgvs_transcript_count += 1
            else:
                raise Exception("Unexpected summary condition")
        
        results['matched_annovar_and_hgvs_transcript_count'] = matched_annovar_and_hgvs_transcript_count
        results['unmatched_annovar_transcript_count'] = unmatched_annovar_transcript_count
        results['unmatched_hgvs_transcript_count'] = unmatched_hgvs_transcript_count    
        results['merged_transcript_count'] = len(merged_transcripts)
                
        merged_distinct_variant_count = len(set(map(lambda x: Variant(x.chromosome, x.position, x.reference, x.alt), merged_transcripts)))
        results['merged_distinct_variant_count'] = merged_distinct_variant_count 
        
        # Sanity check: The number of HGVS transcripts minus the count of merged HGVS transcripts is equal to the number of merged HGVS and annovar transcripts.    
        sanity_check_hgvs = (len(hgvs_transcripts) - unmatched_hgvs_transcript_count) == matched_annovar_and_hgvs_transcript_count
        if not sanity_check_hgvs:
            self.logger.debug(f"Failed sanity check 'sanity_check_hgvs': {len(hgvs_transcripts)} - {unmatched_hgvs_transcript_count} != {matched_annovar_and_hgvs_transcript_count}")
        
        # Sanity check: The number of annovar transcripts minus the count of merged annovar transcripts is equal to the number of 
        # merged HGVS and annovar transcripts.
        sanity_check_annovar = (len(annovar_transcripts) - unmatched_annovar_transcript_count) == matched_annovar_and_hgvs_transcript_count    
        if not sanity_check_annovar:
            self.logger.debug(f"Failed Annovar sanity check: {len(annovar_transcripts)} - {unmatched_annovar_transcript_count} != {matched_annovar_and_hgvs_transcript_count}")
    
        # Essential sanity check:  
        if not sanity_check_hgvs or not sanity_check_annovar:
            self.logger.info(f'Failed sanity check: Total number of transcripts does not equal sum of matched, and unmatched ({sanity_check_hgvs} and {sanity_check_annovar}).')

        # The number of refseq transcripts that are mapped to a ccds: either the best refseq was able to be mapped or one of the alternatives was able to be mapped.  
        sanity_check_ccds_a = len(ccds_transcripts) == self._ccds_map_counter['ccds_mapped_to_best_refseq'] + self._ccds_map_counter['other_accession_version_mapped']
        
        # The number of refseq transcripts that couldn't be mapped to a ccds: the no alternatives to consider or the alternatives couldn't be mapped. 
        sanity_check_ccds_b = len(refseq_transcripts) - len(ccds_transcripts) == self._ccds_map_counter['other_accession_version_not_mapped'] + self._ccds_map_counter['no_alternatives_to_consider']
        
        sanity_check = sanity_check_hgvs and sanity_check_annovar and sanity_check_ccds_a and sanity_check_ccds_b
        results['sanity_check'] = sanity_check
    
        return results
    
    def _log_summary(self, results: dict):
        '''
        Display summary of updated transcripts
        ''' 
        self.logger.info(f"Number of distinct variants from Annovar: {results['annovar_distinct_variant_count']}")    
        self.logger.info(f"Number of annovar transcripts: {results['annovar_transcript_count']}")
        self.logger.info(f"Number of Annovar transcripts that are splice variants: {results['annovar_splice_variant_transcript_count']}")    
        self.logger.info(f"Number of HGVS transcripts: {results['hgvs_transcript_count']}")
        self.logger.info(f"Number of distinct variants from HGVS: {results['hgvs_distinct_variant_count']}")
        self.logger.info(f"Number of transcripts matched in Annovar and HGVS: {results['matched_annovar_and_hgvs_transcript_count']}")
        self.logger.info(f"Number of Annovar transcripts not matched with HGVS transcripts: {results['unmatched_annovar_transcript_count']}")
        self.logger.info(f"Number of HGVS transcripts not matched with Annovar transcripts: {results['unmatched_hgvs_transcript_count']}")
        self.logger.info(f"Number of distinct variants in merged transcript list: {results['merged_distinct_variant_count']}")
        self.logger.info(f"Number of RefSeq transcripts: {results['refseq_transcripts']}")
        self.logger.info(f"Number of CCDS transcripts: {results['ccds_transcripts']}")
        self.logger.info(f"Results of mapping CCDS: {self._ccds_map_counter}")
        self.logger.info(f"Sanity check: {'Passed' if results['sanity_check'] else 'Failed' }")
        
    def get_updated_hgvs_transcripts(self, annovar_transcripts: list):
        '''
        Take a list of transcripts from Annovar and use them to look up the corresponding variants using the HGVS python lib; and then 
        merge the annovar and hgvs info and return the results. 
        '''
        disinct_variants = {Variant(x.chromosome, x.position, x.reference, x.alt) for x in annovar_transcripts}
        
        self.logger.debug(f'{len(disinct_variants)} distinct variants')

        # Lookup the variant in the HGVS/UTA database
        hgvs_transcripts = self._lookup_hgvs_transcripts(disinct_variants)
        self.logger.debug(f'Received {len(hgvs_transcripts)} transcripts from HGVS')
        
        # Merge Annovar and HGVS/UTA transcripgs
        merged_transcripts, unmerged_transcripts = self._merge_annovar_with_hgvs(annovar_transcripts, hgvs_transcripts)
        self.logger.debug(f"Merged {len(merged_transcripts)} Annovar and HGVS transcripts")
        self.logger.debug(f"Found {len(unmerged_transcripts)} unmerged transcripts")
    
        all_transcripts = merged_transcripts + unmerged_transcripts
        
        # When there are multiple versions of a transcript (eg NM_123.1 and NM_123.3) we pick the one that has the most information.
        # We also create copies of refseq transcripts that can be mapped to CCDS accessions.  
        refseq_transcripts, ccds_transcripts = self._get_the_best_refseq_transcripts_and_make_ccds_copies(all_transcripts)

        self._log_summary(self.get_summary(annovar_transcripts, 
                                           disinct_variants, 
                                           hgvs_transcripts, 
                                           merged_transcripts,
                                           refseq_transcripts,
                                           ccds_transcripts))
        
        return refseq_transcripts + ccds_transcripts
            
    def __get_variant_transcript_key(self, transcript: VariantTranscript):
        '''
        Generate a key made up of variant and transcript accession w/o version (eg '7-12345-C-G-NM_123'). 
        '''
        # Take the version off of the transcript
        unversioned_transcript = transcript.refseq_transcript.split('.')[0]
        return f"{transcript.chromosome}-{transcript.position}-{transcript.reference}-{transcript.alt}-{unversioned_transcript}"
    
    def _get_the_best_refseq_transcripts_and_make_ccds_copies(self, transcripts: list):
        '''
        This function accomplishes two goals:
        1) Only have one version of each refseq accession. When there is more than one version of a transcript with RefSeq accession pick the best one. For example if we have VariantTranscripts with 
            accessions NM_123.1 and NM_123.3 and NM_123.1 has combined information from annovar and hgvs/uta but NM_123.3 only has information from 
            annovar then NM_123.3 will be discarded. 
        2) Create CCDS copies of each RefSeq variant transcript. For each of the transcripts that will be returned we check to see if its refseq accession can be mapped to a CCDS accession. When it can be, 
            we create a copy of the VariantTranscript and change the accession to CCDS. 
                    
        When the best transcript from goal (1) doesn't map to a CCDS accession but one of the other versions of that refseq accession does, then we look at those discarded transcripts and see if one of them maps to a CCDS. 
        
        Example: Variant 22-46929555-C-T
            - Hgvs/uta finds transcripts NM_014246.4, NM_014246.3, and NM_014246.1; while Annovar only finds NM_014246.3
            - The best transcript is the one with the most information: NM_014246.3. 
            - But NM_014246.3 doesn't map to a CCDS. 
            - NM_014246.4 and NM_014246.1 both map to a CCDS. 
            - So we create a copy of the variant transcript having accession NM_014246.4, and change it to CCDS14076.1. 
            - Then this function returns NM_014246.3 and CCDS14076.1
        '''
        # Create a dict where the key is the variant genotype and the unversioned transcript; and the value is a list 
        # of all the transcripts with that prefix that are associated with that genotype.
        # Example: 
        #    transcript_dict['1-123-A-C-NM_001] = [NM_001.1, NM001.2]
        transcript_dict = defaultdict(list)
        for transcript in transcripts:        
            transcript_dict[self.__get_variant_transcript_key(transcript)].append(transcript)

        # Select the best refseq trasncript where best is determined by which one has the most fields populated. 
        refseq_transcripts = []
        ccds_transcripts = []
        
        for key in transcript_dict:
            best_transcript = self._get_best_transcript(transcript_dict[key])

            # Annovar doesn't provide a gene for introns and UTR so when that happens lookup the transcript in UTA to see if we can get a gene for it.    
            if not best_transcript.hgnc_gene:
                best_transcript.hgnc_gene = self._get_gene_for_transcript(best_transcript.refseq_transcript)
                if best_transcript.hgnc_gene:
                    self.logger.debug(f"Found gene for transcript {best_transcript}: {best_transcript.hgnc_gene}")
            
            refseq_transcripts.append(best_transcript)
            
            # Find a CCDS transcript equivalent to the refseq      
            ccds_transcript = self._get_ccds_transcript(best_transcript, transcript_dict[key])
            if ccds_transcript:
                ccds_transcripts.append(ccds_transcript)

        return refseq_transcripts, ccds_transcripts

    def _get_ccds_transcript(self, best_transcript, transcripts: list):        
        """
        Return a transcript with CCDS accession that corresponds to the transcript parameters which all have the same RefSeq accessions, but different versions. 
        The ``best_transcript`` parameter is a variant transcript with refseq accession. Ideally we find a ccds mapped to it. 
        The ``transcripts`` parameter is a list of refseq transcripts with the same accession but different versions (eg NM_123.1 and NM_123.3).  
            If there isn't a CCDS that maps to the ``best_transcript``, then this function looks for CCDS that are mapped to one of the ones in the list of ``transcripts``.  
        """
        ccds_accession = self._refseq_ccds_map.get(best_transcript.refseq_transcript)

        # If the transcript maps to a ccds then make a copy of the transcript, swapping out the refseq accession for the ccds 
        if ccds_accession:
            self._ccds_map_counter['ccds_mapped_to_best_refseq'] += 1
            return self._get_ccds_copy_from_refseq(ccds_accession, best_transcript)
        
        if len(transcripts) == 1:
            self._ccds_map_counter['no_alternatives_to_consider'] += 1
            return None
        
        # Since a ccds accession for the best_transcript was not found, we look for a mapping using the other versions of this transcript
        refseqs_that_map_to_ccds = []
        for x in transcripts:
            # Skip the refseq transcript we already checked
            if x == best_transcript:
                continue
            
            # See if this refseq maps to a ccds accession and add it to our list if it does
            ccds_accession = self._refseq_ccds_map.get(x.refseq_transcript)
            if ccds_accession:
                refseqs_that_map_to_ccds.append(x)
            
        if not refseqs_that_map_to_ccds:
            self._ccds_map_counter['other_accession_version_not_mapped'] += 1
            return None
        
        # From the list of refseq transcripts in refseqs_that_map_to_ccds choose one
        best_alternative = self._get_best_transcript(refseqs_that_map_to_ccds)
        
        ccds_accession = self._refseq_ccds_map.get(best_alternative.refseq_transcript)

        self._ccds_map_counter['other_accession_version_mapped'] += 1

        return self._get_ccds_copy_from_refseq(ccds_accession, best_alternative)

    def _get_ccds_copy_from_refseq(self, ccds_accession, refseq_transcript):
        """
        Take a RefSeq transcript, make a copy, and change the accession from a RefSeq to a CCDS.
        """
        ccds_transcript = refseq_transcript.get_copy()
        ccds_transcript.refseq_transcript = ccds_accession
        return ccds_transcript
        
    def _get_best_transcript(self, transcripts: list):
        '''
        Take a list of transcripts and return the one that has the most fields filled in. If there is a tie, return the one with the latest version.     
        '''
        # The VariantTranscript's ``__lt__`` function has been overloaded for the purpose of ranking the transcript based on how many non-null fields it has.  
        sorted_by_ascending_score = sorted(transcripts)
        
        # return the last item in the sorted list (the one with the highest score)
        return sorted_by_ascending_score[-1]
    
    def _get_gene_for_transcript(self, transcript_accession: str):
        '''
        Use the HGVS lib to lookup a transcript's gene in UTA. 
        '''
        try:
            rec = self.hdp.get_tx_identity_info(transcript_accession)
        except HGVSDataNotAvailableError as e:
            # if the transcript isn't in uta it throws an exception rather than just returning null
            self.logger.info(str(e))
            rec = None
    
        if rec is not None:
            assert type(rec[6]) == str, "Index six in object returned by hdp.get_tx_identity_info is supposed to the gene."
            return rec[6]
        else:
            return None;

    def _benchmark_start(self, name):
        """
        If benchmarking is enabled, begin timing a function. 
        """
        if not self._benchmarking:
            return
        
        self._benchmarking.start(name)
    
    def _benchmark_stop(self, name):
        """
        If benchmarking is enabled, stop the timer for a function
        """
        if not self._benchmarking:
            return
        
        self._benchmarking.stop(name)
    
    def _benchmark_cancel(self):
        """
        If benchmarking is enabled, cancel the timer  
        """
        if not self._benchmarking:
            return
        
        self._benchmarking.cancel_last()

    def _log_hgvs_benchmarks(self, variant: Variant, cnt_transcripts):
        """
        Update the a log file with the results of the benchmarking performed during execution of multiple HGVS functions.
        """
        if not self._benchmarking:
            return
        
        for name in self._benchmarking.get_names():            
            self._benchmark_csv_writer.writerow([self._variant_counter, variant, name, cnt_transcripts, self._benchmarking.get_time_total(name), self._benchmarking.get_time_average(name)])
         
        # Clear the timers after each log
        self._benchmarking.clear()
    
    def _increment_variant_counter(self):
        """
        Keep track of how many variants have been processed and output a message after every 1000 variants 
        """
        self._lock.acquire()
        self._variant_counter = self._variant_counter + 1
        if self._variant_counter % 1000 == 0:
            self.logger.info(f"Processed variant {self._variant_counter}")
        self._lock.release()        
